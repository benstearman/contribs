services:
  # --- 1. Web Service (Django/DRF Backend) ---
  web:
    build: .
    container_name: contribs_web
    
    # *** IMPORTANT: We removed the root-level 'env_file' key to fix the validation error. ***
    
    # Command to run the Django development server
    command: python manage.py runserver 0.0.0.0:${WEB_PORT}
    
    # Maps local project root (containing 'backend/') to the container's working directory
    volumes:
      - .:/srv/contribs/backend
      
    # Maps host port to container port (using WEB_PORT from .env)
    # ports:
    #  - "${WEB_PORT}:${WEB_PORT}"
      
    # Passes environment variables into the Django container for settings.py to read
    environment:
      # Database Connection
      - DB_NAME=${POSTGRES_DB}
      - DB_USER=${POSTGRES_USER}
      - DB_PASSWORD=${POSTGRES_PASSWORD}
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      
      # Django Configuration
      - SECRET_KEY=${DJANGO_SECRET_KEY}
      - ALLOWED_HOSTS=${DJANGO_ALLOWED_HOSTS}
      - PYTHONUNBUFFERED=1 # Ensures Python output is immediately visible
      
    # Ensures the web service starts only after the db service is available
    depends_on:
      - db

# --- 2. Caddy Reverse Proxy Service ---
  caddy:
    # --- CRITICAL CHANGE ---
    build: 
      context: .
      dockerfile: Dockerfile.caddy
    # -----------------------
      
    container_name: contribs_caddy
    ports:
    #  - "80:80"
      - "443:443"
    
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
    
    environment:
      CADDY_DOMAIN: ${CADDY_DOMAIN}
      CLOUDFLARE_API_TOKEN: ${CLOUDFLARE_API_TOKEN}
      CADDY_LOG_LEVEL: ${CADDY_LOG_LEVEL}
    
    depends_on:
      - web
  # --- 3. Database Service (PostgreSQL) ---
  db:
    image: postgres:15-alpine
    container_name: contribs_db
    
    # Environment variables to initialize the PostgreSQL database
    # These use the values defined in your .env file
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      
    # Use a named volume to persist the database data
    volumes:
      - postgres_data:/var/lib/postgresql/data/

# --- 4. Portainer Management Interface ---
  portainer:
    image: portainer/portainer-ce:latest
    container_name: contribs_portainer
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    
    # Expose the Portainer UI port (9443 is the standard HTTPS port)
    # You will access this via the Ubuntu Guest IP: 10.0.0.101:9443
    ports:
      - "9000:9000"
      #- "9443:9443"
    
    volumes:
      # This binds the Docker host socket into the container.
      # This allows Portainer to manage Docker itself.
      - /var/run/docker.sock:/var/run/docker.sock
      # Persist Portainer's configuration data
      - portainer_data:/data

  pgadmin:
    image: dpage/pgadmin4
    container_name: contribs_pgadmin
    restart: always
    environment:
      # Required for initial setup
      PGADMIN_DEFAULT_EMAIL: admin@contribs.app
      PGADMIN_DEFAULT_PASSWORD: CdhvujxmQxpVPEa1 # CHOOSE A SECURE PASSWORD
      # Configure the default server connection (to your existing 'db' container)
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      # Map the host's 5050 port to the container's 80 port (default for pgAdmin web interface)
      - "5050:80"
    volumes:
      # Keep pgAdmin's configuration persistent
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      - db # Ensure the database is running before pgAdmin starts

# --- Volumes ---
volumes:
  postgres_data:
  caddy_data: # Define the new volume for Caddy data/certs
  portainer_data: # Define the new volume for Portainer data
  pgadmin_data: # Add a new volume for pgAdmin persistence
